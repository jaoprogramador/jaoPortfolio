{"pageProps":{"post":{"date":"2025-04-09T17:00:00.000Z","slug":"eightblog","preview":"Los principios SOLID son un conjunto de reglas que ayudan a los desarrolladores a escribir código más estructurado, flexible y fácil de mantener. Descubre cómo aplicarlos en tu desarrollo.","title":"Introducción a los Principios SOLID","tagline":"Aprende los principios SOLID para escribir código más limpio y mantenible.","image":"https://images.unsplash.com/photo-1618367588411-d9a90fefa881?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1074&q=80","content":"# ¿Qué son los Principios SOLID?\r\n\r\nLos principios SOLID son un conjunto de buenas prácticas de diseño de software propuestas por Robert C. Martin. Su objetivo es mejorar la calidad, mantenibilidad y escalabilidad del código.\r\n\r\n## ¿Por qué usar los principios SOLID?\r\n\r\nCódigo más limpio y organizado.\r\n\r\nFacilita la reutilización y mantenimiento.\r\n\r\nMejora la escalabilidad y flexibilidad del software.\r\n\r\nReduce el acoplamiento entre componentes.\r\n\r\n## Los Principios SOLID\r\n\r\n1. Principio de Responsabilidad Única **(SRP - Single Responsibility Principle)**\r\n\r\nCada clase debe tener una única razón para cambiar, es decir, debe tener una sola responsabilidad.\r\n```jsx\r\nclass Reporte {\r\n  generarPDF() {\r\n    // Lógica para generar PDF\r\n  }\r\n}\r\n```\r\nPara cumplir SRP, separamos las responsabilidades:\r\n```jsx\r\nclass Reporte {\r\n  obtenerDatos() {\r\n    // Obtener datos del reporte\r\n  }\r\n}\r\n\r\nclass ExportadorPDF {\r\n  exportar(reporte) {\r\n    // Generar PDF con los datos\r\n  }\r\n}\r\n```\r\n## 2. Principio de Abierto/Cerrado **(OCP - Open/Closed Principle)**\r\n\r\nLas clases deben estar abiertas para su extensión, pero cerradas para modificación.\r\n```jsx\r\nclass CalculadoraArea {\r\n  calcular(figura) {\r\n    return figura.area();\r\n  }\r\n}\r\n```\r\nCada nueva figura solo necesita implementar un método area() sin modificar CalculadoraArea.\r\n\r\n## 3. Principio de Sustitución de Liskov **(LSP - Liskov Substitution Principle)**\r\n\r\nLas clases derivadas deben poder sustituir a sus clases base sin alterar el comportamiento esperado.\r\n```jsx\r\nclass Ave {\r\n  volar() {\r\n    return \"Volando\";\r\n  }\r\n}\r\n\r\nclass Pinguino extends Ave {\r\n  volar() {\r\n    throw new Error(\"Los pingüinos no pueden volar\");\r\n  }\r\n}\r\n```\r\nEste código rompe LSP, porque Pinguino no puede reemplazar a Ave. Una mejor solución es usar composición en lugar de herencia.\r\n\r\n## 4. Principio de Segregación de Interfaces **(ISP - Interface Segregation Principle)**\r\n\r\nLas interfaces deben ser específicas para cada necesidad en lugar de ser genéricas y forzar la implementación de métodos innecesarios.\r\n```jsx\r\nclass Trabajador {\r\n  trabajar() {}\r\n  comer() {}\r\n}\r\n```\r\nEn su lugar, dividimos en interfaces más específicas:\r\n```jsx\r\nclass ITrabajador {\r\n  trabajar() {}\r\n}\r\n\r\nclass ICome {\r\n  comer() {}\r\n}\r\n```\r\n## 5. Principio de Inversión de Dependencias **(DIP - Dependency Inversion Principle)**\r\n\r\nLos módulos de alto nivel no deben depender de módulos de bajo nivel, sino de abstracciones.\r\n```jsx\r\nclass MySQLDatabase {\r\n  conectar() {\r\n    return \"Conectando a MySQL\";\r\n  }\r\n}\r\n\r\nclass Aplicacion {\r\n  constructor() {\r\n    this.db = new MySQLDatabase();\r\n  }\r\n}\r\n```\r\n## Este código rompe DIP porque Aplicacion depende directamente de MySQLDatabase. En su lugar, usamos una abstracción:\r\n```jsx\r\nclass Database {\r\n  conectar() {}\r\n}\r\n\r\nclass MySQLDatabase extends Database {\r\n  conectar() {\r\n    return \"Conectando a MySQL\";\r\n  }\r\n}\r\n\r\nclass Aplicacion {\r\n  constructor(db) {\r\n    this.db = db;\r\n  }\r\n}\r\n```\r\n## Conclusión\r\n\r\nLos principios **SOLID** ayudan a escribir código más estructurado, mantenible y escalable. Aplicarlos correctamente mejorará la calidad de tus proyectos y facilitará la colaboración en equipo"}},"__N_SSG":true}