{"pageProps":{"post":{"date":"2025-08-26T17:00:00.000Z","slug":"fiveteen","preview":"La Arquitectura Hexagonal, también conocida como Ports and Adapters, es un patrón que ayuda a diseñar aplicaciones desacopladas y fáciles de mantener. Aprende cómo implementarla en tus proyectos Java Spring y organiza tu código con una arquitectura de paquetes clara.","title":"Arquitectura Hexagonal en Java Spring. Guía para construir aplicaciones mantenibles y escalables","tagline":"Cómo aplicar la Arquitectura Hexagonal para mejorar tus proyectos Spring","image":"/images/blogs/moritz-ludtke-K4n6CW8so84-unsplash.jpg","content":"# Arquitectura Hexagonal en Java Spring: Guía para construir aplicaciones mantenibles y escalables\r\n\r\nLa Arquitectura Hexagonal, o Ports and Adapters, es un patrón de diseño que busca desacoplar el núcleo de la aplicación de las dependencias externas como bases de datos, APIs o interfaces de usuario.\r\n\r\nEste enfoque promueve la separación clara de responsabilidades, lo que facilita pruebas, mantenimiento y escalabilidad en aplicaciones Java Spring.\r\n\r\n---\r\n\r\n## Arquitectura de Paquetes recomendada\r\n\r\nOrganizar tu proyecto en paquetes bien definidos es clave para que la Arquitectura Hexagonal sea efectiva y fácil de mantener. Una estructura común es:\r\n```text\r\ncom.tuempresa.tuapp\r\n├── domain\r\n│ ├── model # Entidades y objetos de dominio\r\n│ ├── service # Lógica de negocio (casos de uso)\r\n│ └── port\r\n│ ├── in # Puertos de entrada (interfaces que exponen funcionalidades)\r\n│ └── out # Puertos de salida (interfaces para dependencias externas)\r\n├── adapter\r\n│ ├── in # Adaptadores para puertos de entrada (por ejemplo, controladores REST)\r\n│ └── out # Adaptadores para puertos de salida (por ejemplo, repositorios, clientes API)\r\n└── config # Configuraciones de Spring, Beans, etc.\r\n```\r\n\r\n---\r\n\r\n## ¿Qué va en cada paquete?\r\n\r\n### 1. **domain**\r\n\r\nAquí reside el **corazón** de tu aplicación. El dominio contiene:\r\n\r\n- **model:** Las entidades de negocio y objetos de valor, 100% independientes de frameworks o tecnología.\r\n- **service:** Casos de uso y reglas de negocio. Aquí defines las operaciones que tu aplicación realiza.\r\n- **port/in:** Interfaces que definen qué funcionalidades ofrece tu dominio hacia el exterior. Por ejemplo, interfaces de servicios.\r\n- **port/out:** Interfaces que definen las dependencias externas que el dominio necesita, como repositorios o servicios externos. El dominio no sabe cómo se implementan, solo que existen.\r\n\r\n---\r\n\r\n### 2. **adapter**\r\n\r\nAquí implementas los **detalles técnicos** que interactúan con el dominio a través de los puertos.\r\n\r\n- **adapter/in:** Adaptadores que consumen los puertos de entrada, típicamente controladores REST, listeners o interfaces de usuario.\r\n- **adapter/out:** Implementaciones concretas de los puertos de salida, como repositorios que usan JPA, clientes HTTP, servicios externos, etc.\r\n\r\n---\r\n\r\n## Ejemplos prácticos: IN y OUT\r\n\r\n### Puerto IN (entrada)\r\n\r\nInterfaz que define un caso de uso que el dominio ofrece, por ejemplo:\r\n\r\n```java\r\n// domain/port/in/UserServicePort.java\r\npublic interface UserServicePort {\r\n    void registerUser(User user);\r\n    Optional<User> getUserById(Long id);\r\n}\r\n\r\n### Servicio en el dominio que implementa la lógica\r\n\r\n// domain/service/UserService.java\r\npublic class UserService implements UserServicePort {\r\n\r\n    private final UserRepositoryPort userRepository;\r\n\r\n    public UserService(UserRepositoryPort userRepository) {\r\n        this.userRepository = userRepository;\r\n    }\r\n\r\n    @Override\r\n    public void registerUser(User user) {\r\n        // Validaciones, reglas de negocio, etc.\r\n        userRepository.save(user);\r\n    }\r\n\r\n    @Override\r\n    public Optional<User> getUserById(Long id) {\r\n        return userRepository.findById(id);\r\n    }\r\n}\r\n```\r\n## Puerto OUT (salida)\r\n\r\n### Interfaz que define cómo el dominio interactúa con recursos externos:\r\n```java\r\n// domain/port/out/UserRepositoryPort.java\r\npublic interface UserRepositoryPort {\r\n    Optional<User> findById(Long id);\r\n    void save(User user);\r\n}\r\n```\r\n### Adaptador OUT (implementación concreta, e.g., JPA)\r\n```java\r\n// adapter/out/persistence/UserRepositoryAdapter.java\r\n@Repository\r\npublic class UserRepositoryAdapter implements UserRepositoryPort {\r\n\r\n    private final SpringDataUserRepository springDataUserRepository;\r\n\r\n    public UserRepositoryAdapter(SpringDataUserRepository springDataUserRepository) {\r\n        this.springDataUserRepository = springDataUserRepository;\r\n    }\r\n\r\n    @Override\r\n    public Optional<User> findById(Long id) {\r\n        return springDataUserRepository.findById(id);\r\n    }\r\n\r\n    @Override\r\n    public void save(User user) {\r\n        springDataUserRepository.save(user);\r\n    }\r\n}\r\n\r\n```\r\n### Adaptador IN (controlador REST)\r\n```java\r\n// adapter/in/web/UserController.java\r\n@RestController\r\n@RequestMapping(\"/users\")\r\npublic class UserController {\r\n\r\n    private final UserServicePort userService;\r\n\r\n    public UserController(UserServicePort userService) {\r\n        this.userService = userService;\r\n    }\r\n\r\n    @PostMapping\r\n    public ResponseEntity<Void> register(@RequestBody User user) {\r\n        userService.registerUser(user);\r\n        return ResponseEntity.ok().build();\r\n    }\r\n\r\n    @GetMapping(\"/{id}\")\r\n    public ResponseEntity<User> getUser(@PathVariable Long id) {\r\n        return userService.getUserById(id)\r\n            .map(ResponseEntity::ok)\r\n            .orElse(ResponseEntity.notFound().build());\r\n    }\r\n}\r\n```\r\n## Beneficios concretos de esta organización\r\n\r\n- **Dominio puro:** Tu lógica está aislada de frameworks y tecnologías, facilitando tests unitarios puros.\r\n\r\n- **Flexibilidad:** Cambia bases de datos, protocolos o interfaces sin tocar el dominio.\r\n\r\n- **Separación** clara: Los paquetes y responsabilidades son explícitos, mejorando la mantenibilidad.\r\n\r\n- **Escalabilidad:** Añade nuevos adaptadores o casos de uso sin afectar el núcleo.\r\n\r\n## Buenas prácticas\r\n\r\nDefine puertos con interfaces claras y bien documentadas.\r\n\r\nEvita que el dominio conozca implementaciones concretas.\r\n\r\nUsa inyección de dependencias para conectar adaptadores con el dominio.\r\n\r\nAplica pruebas unitarias al dominio y pruebas de integración a los adaptadores.\r\n\r\nMantén el dominio libre de anotaciones específicas de frameworks.\r\n\r\n## Conclusión\r\n\r\nLa Arquitectura Hexagonal en Java Spring es una forma robusta de diseñar aplicaciones desacopladas y mantenibles. La correcta organización en paquetes y la clara definición de puertos y adaptadores son fundamentales para aprovechar al máximo este patrón.\r\n\r\nDominar esta arquitectura te ayudará a construir aplicaciones escalables, flexibles y fáciles de probar"}},"__N_SSG":true}