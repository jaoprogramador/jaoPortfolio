{"pageProps":{"post":{"date":"2025-09-18T17:00:00.000Z","slug":"lambdas","preview":"Java 8 introdujo un conjunto de caracter√≠sticas que revolucionaron la forma en que escribimos c√≥digo en Java. Esta gu√≠a cubre expresiones Lambda, API de Streams, interfaces funcionales, Optional, la nueva API de fecha y hora, y mucho m√°s. Ideal para principiantes, entrevistas t√©cnicas y para quienes migran desde Java 7.","title":"Java 8","tagline":"Domina Lambda, Streams y las principales novedades de Java 8","image":"/images/blogs/lambdas.jpg","content":"# Gu√≠a Completa de Java 8\r\n\r\nJava 8 marc√≥ un antes y un despu√©s en el ecosistema Java. Sus caracter√≠sticas principales permiten escribir c√≥digo m√°s limpio, expresivo y conciso.  \r\n\r\n## ‚úÖ Caracter√≠sticas Clave de Java 8\r\n\r\n- **Expresiones Lambda** ‚Äì Sintaxis compacta para implementar interfaces funcionales.\r\n- **API de Streams** ‚Äì Procesamiento de colecciones de datos de forma declarativa.\r\n- **Interfaces funcionales** ‚Äì Contratos con un solo m√©todo abstracto, como `Predicate`, `Function`, `Consumer`.\r\n- **Referencias de m√©todos** ‚Äì Reutilizaci√≥n de m√©todos existentes de forma elegante.\r\n- **M√©todos predeterminados y est√°ticos en interfaces** ‚Äì Mayor flexibilidad para evolucionar APIs.\r\n- **Clase `Optional`** ‚Äì Manejo seguro de valores nulos.\r\n- **API de fecha y hora (`java.time`)** ‚Äì Mejor control de fechas y zonas horarias.\r\n- **Collectors y mejoras en Map** ‚Äì Reducci√≥n de c√≥digo repetitivo y m√°s operaciones funcionales.\r\n\r\n---\r\n\r\n## üöÄ Ejemplos Pr√°cticos\r\n\r\n### 1. Ejemplo b√°sico con Lambda\r\n```java\r\nRunnable r = () -> System.out.println(\"Hello, Lambda!\");\r\nnew Thread(r).start();\r\n```\r\n\r\n### 2. Iterando una lista\r\n\r\n```java\r\nList<String> list = Arrays.asList(\"Java\", \"Spring\", \"Lambda\");\r\nlist.forEach(item -> System.out.println(item));\r\n\r\n```\r\n\r\n### 3. Filtrando una lista con Streams\r\n\r\n```java\r\nList<String> list = Arrays.asList(\"Java\", \"JavaScript\", \"Python\");\r\nList<String> filteredList = list.stream()\r\n    .filter(s -> s.startsWith(\"J\"))\r\n    .collect(Collectors.toList());\r\nfilteredList.forEach(System.out::println);\r\n\r\n```\r\n### 4. Ordenando con Lambda\r\n\r\n```java\r\nList<String> list = Arrays.asList(\"Java\", \"Lambda\", \"Kafka\");\r\nlist.sort((s1, s2) -> s1.compareTo(s2));\r\nlist.forEach(System.out::println);\r\n\r\n```\r\n### 5. Interfaz Funcional Personalizada\r\n\r\n```java\r\n@FunctionalInterface\r\ninterface Calculator {\r\n    int calculate(int a, int b);\r\n}\r\n\r\npublic static void main(String[] args) {\r\n    Calculator add = (a, b) -> a + b;\r\n    Calculator multiply = (a, b) -> a * b;\r\n\r\n    System.out.println(\"Addition: \" + add.calculate(5, 3));\r\n    System.out.println(\"Multiplication: \" + multiply.calculate(5, 3));\r\n}\r\n\r\n```\r\n### 6. Iteraci√≥n de un Map\r\n\r\n```java\r\nMap<String, Integer> map = new HashMap<>();\r\nmap.put(\"Java\", 8);\r\nmap.put(\"Spring\", 5);\r\nmap.put(\"Lambda\", 1);\r\n\r\nmap.forEach((key, value) -> System.out.println(key + \": \" + value));\r\n\r\n```\r\n### 7. Crear hilos con Lambda\r\n\r\n```java\r\nnew Thread(() -> System.out.println(\"Thread with Lambda\")).start();\r\n\r\n```\r\n### 8. Uso de Comparator con Referencia de M√©todo\r\n\r\n```java\r\nList<String> list = Arrays.asList(\"Java\", \"Lambda\", \"Kafka\");\r\nlist.sort(Comparator.comparingInt(String::length));\r\nlist.forEach(System.out::println);\r\n\r\n```\r\n### 9. Uso de Optional\r\n\r\n```java\r\nOptional<String> optional = Optional.of(\"Java\");\r\noptional.ifPresent(s -> System.out.println(\"Value is present: \" + s));\r\n\r\n```\r\n### 10. Predicados y Funciones Comunes\r\n\r\n```java\r\nPredicate<String> isEmpty = s -> s.isEmpty();\r\nSystem.out.println(isEmpty.test(\"\"));    // true\r\nSystem.out.println(isEmpty.test(\"Java\")); // false\r\n\r\nBiFunction<Integer, Integer, Integer> add = (a, b) -> a + b;\r\nSystem.out.println(add.apply(2, 3)); // 5\r\n\r\nConsumer<String> print = s -> System.out.println(s);\r\nprint.accept(\"Hello, World!\");\r\n\r\nSupplier<String> supplier = () -> \"Java\";\r\nSystem.out.println(supplier.get()); // Java\r\n\r\n```\r\n### 11. Operadores y Transformaciones\r\n```java\r\nFunction<String, Integer> length = s -> s.length();\r\nSystem.out.println(length.apply(\"Lambda\")); // 6\r\n\r\nUnaryOperator<Integer> square = x -> x * x;\r\nSystem.out.println(square.apply(5)); // 25\r\n\r\nBinaryOperator<Integer> multiply = (a, b) -> a * b;\r\nSystem.out.println(multiply.apply(2, 3)); // 6\r\n\r\n```\r\n### 12. Streams Avanzados\r\n```java\r\nList<String> list = Arrays.asList(\"java\", \"spring\", \"lambda\");\r\nList<String> upperList = list.stream()\r\n    .map(String::toUpperCase)\r\n    .collect(Collectors.toList());\r\nupperList.forEach(System.out::println);\r\n\r\nList<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);\r\nint sum = numbers.stream()\r\n    .reduce(0, (a, b) -> a + b);\r\nSystem.out.println(\"Sum: \" + sum); // 15\r\n\r\n```\r\n\r\nüìÖ API de Fecha y Hora en Java 8\r\n\r\n\r\n```java\r\nLocalDate today = LocalDate.now();\r\nLocalDate nextWeek = today.plusWeeks(1);\r\nSystem.out.println(\"Hoy: \" + today);\r\nSystem.out.println(\"La pr√≥xima semana: \" + nextWeek);\r\n\r\nLocalDateTime now = LocalDateTime.now();\r\nSystem.out.println(\"Fecha y hora actual: \" + now);\r\n\r\n```\r\nüîë Ventajas de Java 8\r\n\r\nC√≥digo m√°s conciso y legible.\r\n\r\nFacilita la programaci√≥n funcional.\r\n\r\nReduce el boilerplate.\r\n\r\nMayor facilidad para procesamiento en paralelo con parallelStream().\r\n\r\nüìå Conclusi√≥n\r\n\r\nDominar las caracter√≠sticas de Java 8 es esencial para cualquier desarrollador moderno de Java. Sus expresiones Lambda, Streams y mejoras en APIs facilitan la escritura de c√≥digo limpio, eficiente y f√°cil de mantener.\r\n\r\nExplorar estas caracter√≠sticas y practicarlas en proyectos reales es la mejor forma de sacarles el m√°ximo provecho.\r\n\r\n\r\n"}},"__N_SSG":true}