{"pageProps":{"post":{"date":"2025-08-29T17:00:00.000Z","slug":"kubernetes","preview":"Kubernetes (K8s) es el est√°ndar de facto para orquestar contenedores. Aprende qu√© es, cu√°ndo conviene usarlo, ventajas y desventajas, y c√≥mo orquestar una app de microservicios Spring paso a paso, con ejemplos y comandos b√°sicos.","title":"Kubernetes para Microservicios con Spring","tagline":"Del JAR al cluster: despliega, escala y observa tus microservicios con K8s","image":"/images/blogs/kubernetes.jpg","content":"# Kubernetes para Microservicios con Spring üö¢\r\n\r\nKubernetes (K8s) es una **plataforma de orquestaci√≥n de contenedores** que automatiza el **despliegue, escalado, resiliencia y actualizaci√≥n** de tus aplicaciones.  \r\nSe integra como anillo al dedo con **microservicios en Spring Boot**, empaquetados en **Docker**.\r\n\r\n---\r\n\r\n## ‚úÖ ¬øQu√© es y para qu√© sirve Kubernetes?\r\n\r\n- **Programa contenedores** en un **cluster** de m√°quinas (nodos).\r\n- Gestiona **despliegues declarativos**, **autorreparaci√≥n** (restarts), **escalado** (HPA), **rollouts** y **rollbacks**.\r\n- Proporciona **networking** consistente, **descubrimiento de servicios** y **configuraci√≥n** centralizada.\r\n- Facilita **observabilidad** (m√©tricas, logs, trazas) y **seguridad** (RBAC, policies).\r\n\r\n**√ösalo para**: apps con m√∫ltiples servicios, alta disponibilidad, picos de carga, equipos independientes y CI/CD moderno.\r\n\r\n---\r\n\r\n## ü§î ¬øCu√°ndo usarlo y cu√°ndo no?\r\n\r\n**√ösalo si:**\r\n- Tienes **varios microservicios** y necesitas **escalar** por componente.\r\n- Requieres **alta disponibilidad**, **rollouts** sin downtime y **multi-entorno**/multi-cloud.\r\n- Quieres **infra como c√≥digo** y pipelines de **CI/CD** maduros.\r\n\r\n**Piensa dos veces si:**\r\n- Tu app es **simple/monol√≠tica** con bajo tr√°fico.\r\n- **Equipo peque√±o** sin experiencia en contenedores/DevOps.\r\n- Un **PaaS** (Cloud Run, App Service, Heroku) o **FaaS** cubre tu caso m√°s r√°pido y barato.\r\n\r\n---\r\n\r\n## ‚öñÔ∏è Ventajas y desventajas\r\n\r\n### Ventajas\r\n- **Portabilidad** entre clouds/on-prem.\r\n- **Escalado autom√°tico** y **resiliencia**.\r\n- **Rolling updates/rollbacks** declarativos.\r\n- **Aislamiento** por namespace y pol√≠ticas.\r\n\r\n### Desventajas\r\n- **Curva de aprendizaje** y **complejidad operativa**.\r\n- **Coste** de cluster + observabilidad.\r\n- Requiere **disciplina** (recursos, seguridad, backups).\r\n\r\n---\r\n\r\n## üß© Conceptos clave (mini-glosario √∫til)\r\n\r\n- **Cluster**: conjunto de nodos controlados por el **control plane**.\r\n- **Nodo**: m√°quina (VM/f√≠sica) que ejecuta contenedores.\r\n- **Pod**: m√≠nima unidad desplegable (uno o m√°s contenedores).\r\n- **Deployment**: gestiona r√©plicas y actualizaciones de Pods.\r\n- **Service**: IP/puerto estable para acceder a Pods (ClusterIP/NodePort/LoadBalancer).\r\n- **Ingress**: reglas HTTP para exponer servicios con dominio/paths.\r\n- **ConfigMap/Secret**: config no sensible/sensible para inyectar en Pods.\r\n- **Volume/PersistentVolume**: datos persistentes.\r\n- **StatefulSet**: para cargas **stateful** (orden e identidad).\r\n- **HPA**: autoscaling por CPU/RAM/m√©tricas personalizadas.\r\n- **DaemonSet**: 1 Pod por nodo (agentes).\r\n- **Job/CronJob**: trabajos batch/planificados.\r\n- **Namespace**: segmentaci√≥n l√≥gica.\r\n- **RBAC**: permisos por rol/usuario/SA.\r\n\r\n---\r\n\r\n## üõ†Ô∏è Preparaci√≥n de microservicios Spring (previos recomendados)\r\n\r\n- A√±ade **Spring Actuator** para `/actuator/health` (readiness/liveness).\r\n- Externaliza config (profiles, vars de entorno).  \r\n- Empaqueta con **Docker** o **Jib** (sin Dockerfile).\r\n- Expone **m√©tricas** (Micrometer/Prometheus) y **trazas** (OpenTelemetry).\r\n\r\n---\r\n\r\n## üöÄ Orquestar una app de microservicios Spring en Kubernetes (paso a paso)\r\n\r\n1. **Conteneriza cada servicio**\r\n   - Dockerfile t√≠pico:\r\n     ```dockerfile\r\n     FROM eclipse-temurin:21-jre\r\n     WORKDIR /app\r\n     COPY target/app.jar app.jar\r\n     EXPOSE 8080\r\n     ENTRYPOINT [\"java\",\"-jar\",\"/app/app.jar\"]\r\n     ```\r\n   - O usa **Jib** (sin Dockerfile).\r\n\r\n2. **Crea un cluster local**\r\n   - `minikube start`  √≥  `kind create cluster --name demo`\r\n\r\n3. **Sube im√°genes al registry**\r\n   - Etiqueta y push (`docker tag/push`) a Docker Hub/GHCR o usa `minikube image load`.\r\n\r\n4. **Define manifiestos por servicio (IaC)**\r\n   - Namespace, Deployment (recursos, probes), Service (ClusterIP), ConfigMap/Secret.\r\n\r\n5. **Exposici√≥n HTTP**\r\n   - Instala un **Ingress Controller** (p. ej., NGINX) y crea un **Ingress** por dominio/path.\r\n\r\n6. **Base de datos**\r\n   - Preferible **servicio gestionado** (cloud) o **StatefulSet** con PVC si corre en K8s.\r\n\r\n7. **Observabilidad**\r\n   - **Prometheus/Grafana** (m√©tricas), **Loki/ELK** (logs), **Jaeger/Tempo** (trazas).\r\n\r\n8. **Autoscaling y recursos**\r\n   - Define **requests/limits** y **HPA** por servicio.\r\n\r\n9. **CI/CD**\r\n   - Pipeline: build ‚Üí test ‚Üí image push ‚Üí deploy (kubectl/Helm/Kustomize).\r\n   - Considera **GitOps** con Argo CD.\r\n\r\n10. **Seguridad base**\r\n    - **RBAC**, **NetworkPolicies**, **Pod Security Standards**, secrets cifrados.\r\n\r\n---\r\n\r\n## üì¶ Manifiestos de ejemplo (users-service)\r\n\r\n### Deployment + Service (con probes y recursos)\r\n```yaml\r\napiVersion: apps/v1\r\nkind: Deployment\r\nmetadata:\r\n  name: users-deploy\r\n  labels: { app: users }\r\nspec:\r\n  replicas: 2\r\n  selector:\r\n    matchLabels: { app: users }\r\n  template:\r\n    metadata:\r\n      labels: { app: users }\r\n    spec:\r\n      containers:\r\n        - name: users\r\n          image: ghcr.io/org/users:1.0.0\r\n          ports:\r\n            - containerPort: 8080\r\n          env:\r\n            - name: SPRING_PROFILES_ACTIVE\r\n              value: k8s\r\n            - name: DB_URL\r\n              valueFrom:\r\n                secretKeyRef:\r\n                  name: users-secrets\r\n                  key: db-url\r\n          readinessProbe:\r\n            httpGet: { path: /actuator/health/readiness, port: 8080 }\r\n            initialDelaySeconds: 10\r\n            periodSeconds: 5\r\n          livenessProbe:\r\n            httpGet: { path: /actuator/health/liveness, port: 8080 }\r\n            initialDelaySeconds: 20\r\n            periodSeconds: 10\r\n          resources:\r\n            requests: { cpu: \"200m\", memory: \"256Mi\" }\r\n            limits:   { cpu: \"500m\", memory: \"512Mi\" }\r\n---\r\napiVersion: v1\r\nkind: Service\r\nmetadata:\r\n  name: users-svc\r\nspec:\r\n  selector: { app: users }\r\n  ports:\r\n    - port: 80\r\n      targetPort: 8080\r\n  type: ClusterIP\r\n"}},"__N_SSG":true}