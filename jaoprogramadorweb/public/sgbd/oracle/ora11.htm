<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Ejercicios Oracle</title>
<META http-equiv=Content-Language content=es>
<META content="Programación,Programas,Aplicaciones,Ejercicios, Ejemplos,Tutoriales,Manuales" name=description>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta name="keywords" content="procedimientos y funciones, Oracle, sql, pl/sql, programacion oracle, ejercicios, ejemplos">
<META content=euskalnet.net/jaoprogramador name=author>
<META content="Copyright (c) 2005 jaoprogramador" name=copyright>
<META scheme=RFC1766 content=español name=DC.Language>
<META content=es,sp,spanish,español name=lang>
<META content=all name=robots>
<link href="../../styles/estilos.css" rel="stylesheet" type="text/css">
</head>

<body>
<table class="tablaContenidos">
  <tr> 
    <td height="52" colspan="3"> <h2>E 
        J E R C I C I O S</h2></td>
  </tr>
  <tr> 
    <td> <h3>CREATE 
        OR REPLACE PROCEDURE...</h3><p>
        1.- Ejemplos de creaci&oacute;n procedimientos.</p>
        <p>1) Indicar los errores que aparecen en las siguientes instrucciones y la forma de corregirlos.</p>
        <p>DECLARE<br>
  Num1 NUMBER(8,2) := 0 <br>
  Num2 NUMBER(8,2) NOT NULL DEFAULT 0; <br>
  Num3 NUMBER(8,2) NOT NULL;<br>
  Cantidad INTEGER(3); <br>
  Precio, Descuento NUMBER(6);<br>
  Num4 Num1%ROWTYPE;<br>
  Dto CONSTANT INTEGER; <br>
  BEGIN<br>
  ...<br>
  END;</p>
        <p>Num3 NUMBER(8,2) NOT NULL DEFAULT 0;<br>
          Cantidad INTEGER;<br>
          Precio NUMBER(6);<br>
          Descuento NUMBER(6);<br>
          Num4 Num1%TYPE;</p>
        <p>2) Escribir un procedimiento que reciba dos n&uacute;meros y visualice su suma.<br>
          CREATE OR REPLACE PROCEDURE sumar_numeros (<br>
  num1 NUMBER,<br>
  num2 NUMBER)<br>
  IS<br>
  suma NUMBER(6);<br>
  BEGIN<br>
  suma := num1 + num2;<br>
  DBMS_OUTPUT.PUT_LINE('Suma: '|| suma);<br>
  END sumar_numeros;</p>
        <p>3) Codificar un procedimiento que reciba una cadena y la visualice al rev&eacute;s.<br>
          CREATE OR REPLACE PROCEDURE cadena_reves(<br>
  vcadena VARCHAR2)<br>
  AS<br>
  vcad_reves VARCHAR2(80);<br>
  BEGIN<br>
  FOR i IN REVERSE 1..LENGTH(vcadena) LOOP<br>
  vcad_reves := vcad_reves || SUBSTR(vcadena,i,1);<br>
  END LOOP;<br>
  DBMS_OUTPUT.PUT_LINE(vcad_reves);<br>
  END cadena_reves;</p>
        <p>4) Escribir una funci&oacute;n que reciba una fecha y devuelva el a&ntilde;o, en n&uacute;mero, correspondiente a esa fecha.<br>
          CREATE OR REPLACE FUNCTION anio (<br>
          fecha DATE)<br>
          RETURN NUMBER<br>
          AS<br>
  v_anio NUMBER(4);<br>
  BEGIN<br>
  v_anio := TO_NUMBER(TO_CHAR(fecha, 'YYYY'));<br>
  RETURN v_anio;<br>
  END anio;</p></td>
    <td>&nbsp;</td>
    <td><a href="http://www.euskalnet.net/juanarana/oraclezip/Ejer35.rar"><img src="../imagenes/Descarga.gif" width="16" height="16" border="0"></a></td>
  </tr>
  <tr> 
    <td><h3>CREATE 
      OR REPLACE FUNCTION....</h3><p>
      2 .- Ejemplos de creaci&oacute;n de funciones.</p>
      <p>5) Escribir un bloque PL/SQL que haga uso de la funci&oacute;n anterior.<br>
        DECLARE<br>
n NUMBER(4);<br>
BEGIN<br>
n := anio(SYSDATE);<br>
DBMS_OUTPUT.PUT_LINE('A&Ntilde;O : '|| n);<br>
END;</p>
      <p>6) Dado el siguiente procedimiento:<br>
        CREATE OR REPLACE PROCEDURE crear_depart (<br>
  v_num_dept depart.dept_no%TYPE, <br>
  v_dnombre depart.dnombre%TYPE DEFAULT 'PROVISIONAL',<br>
  v_loc depart.loc%TYPE DEFAULT &lsquo;PROVISIONAL&rsquo;)<br>
  IS<br>
  BEGIN<br>
  INSERT INTO depart<br>
  VALUES (v_num_dept, v_dnombre, v_loc);<br>
  END crear_depart;<br>
  Indicar cu&aacute;les de las siguientes llamadas son correctas y cu&aacute;les incorrectas, en este &uacute;ltimo caso escribir la llamada correcta usando la notaci&oacute;n posicional (en los casos que se pueda):<br>
  crear_depart; -- 1&ordm;<br>
  crear_depart(50); -- 2&ordm; <br>
  crear_depart('COMPRAS'); -- 3&ordm;<br>
  crear_depart(50,'COMPRAS'); -- 4&ordm;<br>
  crear_depart('COMPRAS', 50); -- 5&ordm;<br>
  crear_depart('COMPRAS', 'VALENCIA'); -- 6&ordm;<br>
  crear_depart(50, 'COMPRAS', 'VALENCIA'); -- 7&ordm;<br>
  crear_depart('COMPRAS', 50, 'VALENCIA'); -- 8&ordm;<br>
  crear_depart('VALENCIA', &lsquo;COMPRAS&rsquo;); -- 9&ordm;<br>
  crear_depart('VALENCIA', 50); -- 10&ordm;</p>
      <p>1&ordm; Incorrecta: hay que pasar al menos el n&uacute;mero de departamento.<br>
        2&ordm; Correcta. <br>
        3&ordm; Incorrecta: hay que pasar tambi&eacute;n el n&uacute;mero de departamento.<br>
        4&ordm; Correcta.<br>
        5&ordm; Incorrecta: los argumentos est&aacute;n en orden inverso.<br>
        Soluci&oacute;n: crear_depart(50, 'COMPRAS');<br>
        6&ordm; Incorrecta: hay que pasar tambi&eacute;n el n&uacute;mero.<br>
        7&ordm; Correcta.<br>
        8&ordm; Incorrecta: el orden de los argumentos es incorrecto.<br>
  Soluci&oacute;n: crear_depart(50, 'COMPRAS', 'VALENCIA');<br>
  9&ordm; Incorrecta: hay que pasar tambi&eacute;n el n&uacute;mero de departamento.<br>
  10&ordm; Incorrecta: los argumentos est&aacute;n en orden inverso.<br>
  Soluci&oacute;n: crear_depart(50, NULL, 'VALENCIA');<br>
      </p>
      <p>7) Desarrollar una funci&oacute;n que devuelva el n&uacute;mero de a&ntilde;os completos que hay entre dos fechas que se pasan como argumentos.<br>
        CREATE OR REPLACE FUNCTION anios_dif (<br>
        fecha1 DATE,<br>
  fecha2 DATE)<br>
  RETURN NUMBER<br>
  AS<br>
  v_anios_dif NUMBER(6);<br>
  BEGIN<br>
  v_anios_dif := ABS(TRUNC(MONTHS_BETWEEN(fecha2,fecha1)<br>
  / 12));<br>
  RETURN v_anios_dif;<br>
  END anios_dif;<br>
      </p>
      <p>8) Escribir una funci&oacute;n que, haciendo uso de la funci&oacute;n anterior devuelva los trienios que hay entre dos fechas. (Un trienio son tres a&ntilde;os completos).<br>
        CREATE OR REPLACE FUNCTION trienios (<br>
        fecha1 DATE,<br>
  fecha2 DATE)<br>
  RETURN NUMBER<br>
  AS<br>
  v_trienios NUMBER(6);<br>
  BEGIN<br>
  v_trienios := TRUNC(anios_dif(fecha1,fecha2) / 3);<br>
  RETURN v_trienios;<br>
  END;</p>
      <p></p></td>
    <td>&nbsp;</td>
    <td><a href="http://www.euskalnet.net/juanarana/oraclezip/Ejer36.rar"><img src="../imagenes/Descarga.gif" width="16" height="16" border="0"></a></td>
  </tr>
  <tr> 
    <td> <h3>PROCEDIMIENTOS Y FUNCIONES</h3><p>
	3 .- Ejemplos de procedimientos y funciones.</h3>
      <p>9) Codificar un procedimiento que reciba una lista de hasta 5 n&uacute;meros y visualice su suma.<br>
        CREATE OR REPLACE PROCEDURE sumar_5numeros (<br>
Num1 NUMBER DEFAULT 0,<br>
Num2 NUMBER DEFAULT 0,<br>
Num3 NUMBER DEFAULT 0,<br>
Num4 NUMBER DEFAULT 0,<br>
Num5 NUMBER DEFAULT 0)<br>
AS<br>
BEGIN<br>
DBMS_OUTPUT.PUT_LINE(Num1 + Num2 + Num3 + Num4 + Num5);<br>
END sumar_5numeros;<br>
      <p>10) Escribir una funci&oacute;n que devuelva solamente caracteres alfab&eacute;ticos sustituyendo cualquier otro car&aacute;cter por blancos a partir de una cadena que se pasar&aacute; en la llamada.<br>
        CREATE OR REPLACE FUNCTION sust_por_blancos(<br>
  cad VARCHAR2)<br>
  RETURN VARCHAR2<br>
  AS<br>
  nueva_cad VARCHAR2(30);<br>
  car CHARACTER;<br>
  BEGIN<br>
  FOR i IN 1..LENGTH(cad) LOOP<br>
  car:=SUBSTR(cad,i,1);<br>
  IF (ASCII(car) NOT BETWEEN 65 AND 90)<br>
  AND (ASCII(car) NOT BETWEEN 97 AND 122) THEN<br>
  car :=' ';<br>
  END IF;<br>
  nueva_cad := nueva_cad || car; <br>
  END LOOP;<br>
  RETURN nueva_cad;<br>
  END sust_por_blancos;<br>
      </p>
      <p>11) Implementar un procedimiento que reciba un importe y visualice el desglose del cambio en unidades monetarias de 1, 5, 10, 25, 50, 100, 200, 500, 1000, 2000, 5000 Ptas. en orden inverso al que aparecen aqu&iacute; enumeradas.<br>
        CREATE OR REPLACE PROCEDURE desglose_cambio(<br>
  importe NUMBER)<br>
  AS<br>
  cambio NATURAL := importe;<br>
  moneda NATURAL;<br>
  v_uni_moneda NATURAL;<br>
  BEGIN<br>
  DBMS_OUTPUT.PUT_LINE('***** DESGLOSE DE: ' || importe );<br>
  WHILE cambio &gt; 0 LOOP<br>
  IF cambio &gt;= 5000 THEN<br>
  moneda := 5000;<br>
  ELSIF cambio &gt;= 2000 THEN<br>
  moneda := 2000;<br>
  ELSIF cambio &gt;= 1000 THEN<br>
  moneda := 1000;<br>
  ELSIF cambio &gt;= 500 THEN<br>
  moneda := 500;<br>
  ELSIF cambio &gt;= 200 THEN<br>
  moneda := 200;<br>
  ELSIF cambio &gt;= 100 THEN<br>
  moneda := 100;<br>
  ELSIF cambio &gt;= 50 THEN<br>
  moneda := 50;<br>
  ELSIF cambio &gt;= 25 THEN<br>
  moneda := 25;<br>
  ELSIF cambio &gt;= 10 THEN<br>
  moneda := 10;<br>
  ELSIF cambio &gt;= 5 THEN<br>
  moneda := 5;<br>
  ELSE <br>
  moneda := 1;<br>
  END IF;<br>
  v_uni_moneda := TRUNC(cambio / moneda);<br>
  DBMS_OUTPUT.PUT_LINE(v_uni_moneda || <br>
  ' Unidades de: ' || moneda || ' Ptas. ');<br>
  cambio := MOD(cambio, moneda);<br>
  END LOOP;<br>
  END desglose_cambio;</p>
      <p> <br>
        12) Codificar un procedimiento que permita borrar un empleado cuyo n&uacute;mero se pasar&aacute; en la llamada.<br>
        CREATE OR REPLACE PROCEDURE borrar_emple(<br>
  num_emple emple.emp_no%TYPE)<br>
  AS<br>
  BEGIN<br>
  DELETE FROM emple WHERE emp_no = num_emple;<br>
  END borrar_emple;</p>
      <p>Nota: El procedimiento anterior devolver&aacute; el mensaje <br>
      &lt;&lt; Procedimiento PL/SQL terminado con &eacute;xito &gt;&gt; aunque no exista el n&uacute;mero y, por tanto, no se borre el empleado. Para evitarlo se puede escribir:</p>
      <p>CREATE OR REPLACE PROCEDURE borrar_emple(<br>
  num_emple emple.emp_no%TYPE)<br>
  AS<br>
  v_row ROWID;<br>
  BEGIN<br>
  SELECT ROWID INTO v_row FROM emple <br>
  WHERE emp_no = num_emple;<br>
  DELETE FROM emple WHERE ROWID = v_row;<br>
  END borrar_emple;</p>
      <p>13) Escribir un procedimiento que modifique la localidad de un departamento. El procedimiento recibir&aacute; como par&aacute;metros el n&uacute;mero del departamento y la localidad nueva.<br>
        CREATE OR REPLACE<br>
        PROCEDURE modificar_localidad(<br>
  num_depart NUMBER,<br>
  localidad VARCHAR2)<br>
  AS<br>
  BEGIN<br>
  UPDATE depart SET loc = localidad<br>
  WHERE dept_no = num_depart;<br>
  END modificar_localidad;</p>
      <p>Nota: Lo indicado en la nota del ejercicio anterior se puede aplicar tambi&eacute;n a este.</p>
      <p>14) Visualizar todos los procedimientos y funciones del usuario almacenados en la base de datos y su situaci&oacute;n (valid o invalid).<br>
        SELECT OBJECT_NAME, OBJECT_TYPE, STATUS <br>
        FROM USER_OBJECTS <br>
        WHERE OBJECT_TYPE IN ('PROCEDURE','FUNCTION');</p>
      <p>Nota: Tambi&eacute;n se puede utilizar la vista ALL_OBJECTS. <br>
      </p></td>
    <td>&nbsp;</td>
    <td><a href="http://www.euskalnet.net/juanarana/oraclezip/Ejer37.rar"><img src="../imagenes/Descarga.gif" width="16" height="16" border="0"></a></td>
  </tr>
  <tr> 
    <td><div align="right">
        <a href="http://www.euskalnet.net/juanarana/index3.htm" target="_parent">&lt;&lt;Men&uacute; 
        Inicio</a></div>
</td>
  </tr>
</table>
<p>&nbsp;</p>
</body>
</html>
