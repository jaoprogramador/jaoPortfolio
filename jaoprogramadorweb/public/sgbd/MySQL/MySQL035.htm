<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Ejercicios MySQL</title>
<META http-equiv=Content-Language content=es>
<META content="Programación,Programas,Aplicaciones,Ejercicios, Ejemplos,Tutoriales,Manuales" name=description>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta name="keywords" content="MySQL, sql, pl/sql, programacion MySQL, ejercicios MySQL, ejemplos MySQL, select">
<META content=euskalnet.net/jaoprogramador name=author>
<META content="Copyright (c) 2005 jaoprogramador" name=copyright>
<META scheme=RFC1766 content=español name=DC.Language>
<META content=es,sp,spanish,español name=lang>
<META content=all name=robots>
<link href="../../styles/estilos.css" rel="stylesheet" type="text/css">
</head>

<body>
<table class="tablaContenidos">
  <tr> 
    <td height="39" colspan="3"> <h2>D E L E T E</h2></td>
  </tr>
  <tr> 
    <td><h3>Sintaxis de DELETE</h3>
    	
      <p>Sintaxis para una tabla:<br>
        DELETE [LOW_PRIORITY] [QUICK] [IGNORE] FROM tbl_name<br>
        [WHERE where_definition]<br>
        [ORDER BY ...]<br>
        [LIMIT row_count]<br>
        Sintaxis para m&uacute;ltiples tablas:<br>
        DELETE [LOW_PRIORITY] [QUICK] [IGNORE]<br>
        tbl_name[.*] [, tbl_name[.*] ...]<br>
        FROM table_references<br>
        [WHERE where_definition]<br>
        O:<br>
        DELETE [LOW_PRIORITY] [QUICK] [IGNORE]<br>
        FROM tbl_name[.*] [, tbl_name[.*] ...]<br>
        USING table_references<br>
        [WHERE where_definition]<br>
        DELETE borra los registros de tbl_name que satisfacen la condici&oacute;n 
        dada por where_definition, y retorna el n&uacute;mero de<br>
        registros borrados.<br>
        Si realiza un comando DELETE sin cl&aacute;usula WHERE se borran todos 
        los registros. Una forma m&aacute;s r&aacute;pida de hacerlo, cuando no<br>
        quiere saber el n&uacute;mero de registros borrados, se usa TRUNCATE TABLE. 
        Consulte Secci&oacute;n 13.2.9, &#8220;Sintaxis de TRUNCATE&#8221;.<br>
        Si borra el registro conteniendo el m&aacute;ximo valor para una columna 
        AUTO_INCREMENT , el valor se re&uacute;sa para una tabla BDB , pero<br>
        no para tablas MyISAM o InnoDB . Si borra todos los registros en la tabla 
        con DELETE FROM tbl_name (sin cl&aacute;usula WHERE<br>
        ) en modo AUTOCOMMIT , la secuencia comienza para todos los tipos de tabla 
        excepto para InnoDB y MyISAM. Hay algunas<br>
        excepciones para este comportamiento para tablas InnoDB , como se discute 
        en Secci&oacute;n 15.6.3, &#8220;C&oacute;mo funciona una columna<br>
        AUTO_INCREMENT en InnoDB&#8221;.<br>
        Para tablas MyISAM y BDB , puede especificar una columna AUTO_INCREMENT 
        secundaria en una clave de m&uacute;ltiples columnas.<br>
        En este caso, el re&uacute;so de valores borrados del inicio de la secuencia 
        se realiza incluso para tablas MyISAM . Consulte Secci&oacute;n 3.6.9,<br>
        &#8220;Utilizaci&oacute;n de AUTO_INCREMENT&#8221;.<br>
        El comando DELETE soporta los siguientes modificadores:<br>
        &#8226; Si especifica LOW_PRIORITY, la ejecuci&oacute;n de DELETE se retarda 
        hasta que no hay m&aacute;s clientes leyendo de la tabla.<br>
        &#8226; Para tablas MyISAM , si usa la palabra QUICK , el motor de almacenamiento 
        no mezcla las hojas del &iacute;ndice durante el borrado,<br>
        que puede acelerar algunos tipos de operaciones de borrado.<br>
        &#8226; En MySQL 5.0, la palabra clave IGNORE hace que MySQL ignore todos 
        los errores durante el proceso de borrar registros. (Los<br>
        errores encontrados durante la etapa de parseo se procesan de la forma 
        habitual.) Los errores que se ignoran debido al uso de esta<br>
        opci&oacute;n se retornan como advertencias.<br>
        La velocidad de las operaciones de borrado pueden verse afectadas por 
        factores discutidos en Secci&oacute;n 7.2.16, &#8220;Velocidad de sentencias<br>
        DELETE&#8221;.<br>
        En tablas MyISAM , los registros borrados se mantienen en una lista enlazada 
        y las operaciones INSERT siguientes re&uacute;san antiguas<br>
        posiciones de registro. Para reclamar espacio no usado y reducir tama&ntilde;o 
        de fichero, use el comando OPTIMIZE TABLE o la utilidad<br>
        myisamchk para reorganizar las tablas. OPTIMIZE TABLE es m&aacute;s sencillo, 
        pero myisamchk es m&aacute;s r&aacute;pido. Consulte Secci&oacute;n<br>
        13.5.2.5, &#8220;Sintaxis de OPTIMIZE TABLE&#8221; y Secci&oacute;n 5.8.3.10, 
        &#8220;Optimizaci&oacute;n de tablas&#8221;.<br>
        El modificador QUICK afecta si las hojas del &iacute;ndice es mezclan 
        en operaciones de borrado. DELETE QUICK es m&aacute;s &uacute;til para 
        aplicaciones<br>
        en que los valores del &iacute;ndice para registros borrados se replazan 
        con valores similares de registros insertados posteriormente.<br>
        En este caso, los agujeros dejados por los valores borrados se re&uacute;san.<br>
        DELETE QUICK no es &uacute;til cuando los valores borrados conducen a 
        bloques de &iacute;ndices no rellenos con un rango de valores &iacute;ndice<br>
        para el que vuelven a ocurrir nuevas inserciones. En este caso, el uso 
        de QUICK puede conducir a un gasto de espacio que queda<br>
        sin reclamar. Aqu&iacute; hay un ejemplo de este escenario:<br>
        1. Cree una tabla que contenga una columna AUTO_INCREMENT indexada.<br>
        2. Inserta varios registros en la tabla. Cada inserci&oacute;n resulta 
        en un valor &iacute;ndice que se a&ntilde;ade al final del &iacute;ndice.<br>
        3. Borra un bloque de registros al final del rango de la columna usando 
        DELETE QUICK.<br>
        En este escenario, los bloques de &iacute;ndice asociados con los valores 
        de &iacute;ndice borrado quedan sin rellenar pero no se mezclan con<br>
        otros bloques de &iacute;ndice debido al uso de QUICK. Quedan sin rellenar 
        cuando hay nuevas inserciones, ya que los nuevos registros no<br>
        tienen valores &iacute;ndice en el rango borrado. Adem&aacute;s, quedan 
        sin rellenar incluso si luego usa DELETE sin QUICK, a no ser que algunos<br>
        de los valores de &iacute;ndice borrados est&eacute;n en los bloques de 
        &iacute;ndice dentro o adyacentes a los bloques no rellenos. Para reclamar 
        el<br>
        espacio de &iacute;ndice sin usar bajo estas circunstancias use OPTIMIZE 
        TABLE.<br>
        Si va a borrar varios registros de una tabla, puede ser m&aacute;s sencillo 
        usar DELETE QUICK seguido por OPTIMIZE TABLE. Esto<br>
        reconstruye el &iacute;ndice en lugar de realizar varias operaciones de 
        mezcla de bloques de &iacute;ndice.<br>
        La opci&oacute;n de MySQL LIMIT row_count para DELETE le dice al servidor 
        el m&aacute;ximo n&uacute;mero de registros a borrar antes de retornar<br>
        el control al cliente. Esto puede usarse para asegurar que un comando 
        DELETE espec&iacute;fico no tarada demasiado tiempo. Puede<br>
        simplemente repetir el comando DELETE hasta que el n&uacute;mero de registros 
        afectados sea menor que el valor LIMIT .<br>
        Si el comando DELETE incluye una cl&aacute;usula ORDER BY , los registros 
        se borran en el orden especificado por la cl&aacute;usula. Esto es<br>
        muy &uacute;til s&oacute;lo en conjunci&oacute;n con LIMIT. Por ejemplo, 
        el siguiente ejemplo encuentra registros coincidentes con la cl&aacute;usula 
        WHERE<br>
        ordenados por timestamp_column, y borra el primero (el m&aacute;s viejo).<br>
        DELETE FROM somelog<br>
        WHERE user = 'jcole'<br>
        ORDER BY timestamp_column<br>
        LIMIT 1;<br>
        Puede especificar m&uacute;ltiples tablas en un comando DELETE para borrar 
        registros de una o m&aacute;s tablas dependiendo de una condici&oacute;n<br>
        particular en m&uacute;ltiples tablas. Sin embargo, no puede usar ORDER 
        BY o LIMIT en un DELETE de m&uacute;ltiples tablas.<br>
        La parte table_references lista las tablas involucradas en el join. Esta 
        sintaxis se describe en Secci&oacute;n 13.2.7.1, &#8220;Sintaxis de<br>
        JOIN&#8221;.<br>
        Para la primera sintaxis, s&oacute;lo los registros coincidentes de las 
        tablas listadas antes de la cl&aacute;usula FROM se borran. Para la segunda<br>
        sintaxis, s&oacute;lo los registros coincidentes de las tablas listadas 
        en la cl&aacute;usula FROM (antes de la cl&aacute;usula USING ) se borran. 
        El efecto<br>
        es que puede borrar registros para varias tablas al mismo tiempo y tienen 
        tablas adicionales que se usan para buscar:<br>
        DELETE t1, t2 FROM t1, t2, t3 WHERE t1.id=t2.id AND t2.id=t3.id;<br>
        O:<br>
        DELETE FROM t1, t2 USING t1, t2, t3 WHERE t1.id=t2.id AND t2.id=t3.id;<br>
        Estos comandos usan las tres tablas al buscar registros a borrar, pero 
        borrar los registros coincidentes s&oacute;lo para las tablas t1 y t2.<br>
        Los ejemplos anteriores muestran inner joins usando el operador coma, 
        pero comandos DELETE de varias tablas pueden usar cualquier<br>
        tipo de join permitido por comandos SELECT tales como LEFT JOIN.<br>
        La sintaxis permite .* tras los nombres de tabla para compatibilidad con 
        Access.<br>
        Si usa un comando DELETE de varias tablas incluyendo tablas InnoDB para 
        las que hay restricciones de clave for&aacute;nea, el optimizador<br>
        MySQL puede procesar tablas en un orden ditinto del de su relaci&oacute;n 
        padre/hijo. En este caso, el comando falla y se deshace.<br>
        En su lugar, debe borrar de una tabla &uacute;ncia y confiar en la capacidad 
        de ON DELETE que proporciona InnoDB para hacer que las<br>
        otras tablas se modifiquen correctamente.<br>
        Nota: En MySQL 5.0, debe usar el alias (si se di&oacute;) al referirse 
        a un nombre de tabla:<br>
        En MySQL 4.1:<br>
        DELETE t1 FROM test AS t1, test2 WHERE ...<br>
        Borrados cruzados entre bases de datos se soportan para borrados de varias 
        tablas, pero en este caso, debe referirse a las tablas sin<br>
        usar alias. Por ejemplo:<br>
        DELETE test1.tmp1, test2.tmp2 FROM test1.tmp1, test2.tmp2 WHERE ...<br>
        Actualmente, no puede borrar desde una tabla y seleccionar de la misma 
        tabla en una subconsulta. </p>
        </td>
    <td>&nbsp;</td>
    <td><a href="http://www.euskalnet.net/juanarana/oraclezip/Ejer3.rar"><img src="../../imagenes/Descarga.gif" width="16" height="16" border="0"></a></td>
  </tr>
  <tr> 
    <td>
<div align="right"><a href="http://www.euskalnet.net/juanarana/index3.htm" target="_parent">&lt;&lt;Men&uacute; 
        Inicio</a>
      </div></td>
  </tr>
</table>
<p>&nbsp;</p>
</body>
</html>
