<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Timer Service</title>
<META http-equiv=Content-Language content=es>
<META content="Programación en EJB 3.0 Timer Service,Programas EJB 3.0 Timer Service,Aplicaciones en EJB 3.0 Timer Service,Ejercicios en EJB 3.0 Timer Service, Ejemplos de EJB 3.0 Timer Service,Tutorial de EJB 3.0 Timer Service,Manual EJB 3.0 Timer Service" name=description>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta name="keywords" content="EJB 3.0 Timer Service, Manual EJB 3.0 Timer Service, tutorial EJB 3.0 Timer Service, Ejemplos EJB 3.0 Timer Service, ejercicios EJB 3.0 Timer Service">
<META content=euskalnet.net/jaoprogramador name=author>
<META content="Copyright (c) 2005 jaoprogramador" name=copyright>
<META scheme=RFC1766 content=español name=DC.Language>
<META content=es,sp,spanish,español name=lang>
<META content=all name=robots>
<link href="../../styles/estilos.css" rel="stylesheet" type="text/css">
</head>

<body>
<table class="tablaContenidos">

  <tr> 
    <td height="39" colspan="3"> <h2> Timer Service</h2></td>
  </tr>
  <tr> 
    <td height="258" colspan="3"> <p>Se suele utilizar cuando deseamos realizar 
        un proceso controlado temporalmente, ya sea en una fecha determinada o 
        cada cierto intervalo de tiempo.</p>
      <p><br>
        Se suele utilizar un Stateless Session Bean o un Message-driven Bean. 
        Los EJB 3.0 Entities NO estan disponibles para Timer Service.</p>
      <p><br>
        TimedObject<br>
        Para poder utilizar Timer Service, un Stateless Session Bean o un Message-Driven 
        Bean deben implementar la la interfaz TimedObject, que consta de un s&oacute;lo 
        m&eacute;todo.<br>
        En el estandar EJB3.0 existe tambi&eacute;n la posibilidad de dotar a 
        cualquier m&eacute;todo con la anotaci&oacute;n @javax.ejb.Timeout</p>
      <p><br>
        La ventaja de utilizar como temporizador un stateless session bean reside 
        en que se pueden ofrecer m&eacute;todos al cliente a trav&eacute;s<br>
        de la interfaz para iniciar y detener el temporizador.</p>
      <p>public class AlarmSchedulerBean implements AlarmSchedulerRemote {<br>
        @Resource<br>
        TimerService timerService;<br>
        public static final String COMANDO = &quot;HSP&quot;;<br>
        public void startMonitor() {<br>
        timerService.createTimer(1 * 1000, 1 * 1000, COMANDO);<br>
        }<br>
        public void stopMonitor() {<br>
        for (Object obj : timerService.getTimers()) {<br>
        Timer timer = (Timer) obj;<br>
        String info = (String)timer.getInfo();<br>
        if (info.equals(COMANDO)) {<br>
        timer.cancel();<br>
        }<br>
        }<br>
        }<br>
        @Timeout<br>
        public void timeout(Timer timer) {<br>
        String info = (String)timer.getInfo();<br>
        if (info.equals(COMANDO)) {<br>
        System.out.println(&quot;Liberando memoria: &quot;+ Runtime.getRuntime().freeMemory());<br>
        }<br>
        }<br>
        }<br>
      </p>
      </td>
  </tr>
  <tr> 
    <td width="66" height="21"></td>
    <td width="324" height="21">&nbsp;</td>
    <td width="149"><div align="right"><a href="../index.htm" target="_parent">&lt;&lt;Men&uacute; 
        Inicio</a></div></td>
  </tr>
</table>
<p>&nbsp;</p>
</body>
</html>
